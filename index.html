<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>sub5conscious Ver 2.6</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #050510; --line: #334; --p1: #00ffff; --p2: #ff00ff;
            --text: #ccddff; --ui: rgba(10,10,20,0.98); --font: 'Courier New', monospace;
        }
        [data-theme="light"] {
            --bg: #f2f4f6; --line: #b0b2b4; --p1: #006688; --p2: #880066; --text: #223;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        body {
            margin: 0; background: var(--bg); color: var(--text); font-family: var(--font);
            height: 100vh; overflow: hidden; user-select: none;
        }
        
        /* Scene Management */
        .scene { display: none; width: 100%; height: 100%; flex-direction: column; position: absolute; }
        .active { display: flex; }
        
        /* Layout: Type 1 "The Standard" */
        .ui-bar { height: 85px; padding: 10px 20px; display: flex; flex-direction: column; justify-content: center; z-index: 50; }
        .timer-info { display: flex; justify-content: space-between; font-size: 14px; font-weight: bold; letter-spacing: 1px; }
        .bar-track { width: 100%; height: 8px; background: rgba(128,128,128,0.15); margin: 8px 0; overflow: hidden; border: 1px solid rgba(255,255,255,0.05); }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s linear, background 0.3s; }
        
        #stage { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; padding: 10px; }
        #grid { 
            display: grid; grid-template-columns: repeat(8, 1fr); 
            width: 100%; max-width: 480px; aspect-ratio: 1/1; 
            border: 2px solid var(--line); background: rgba(255,255,255,0.02);
        }
        .cell { border: 0.5px solid var(--line); position: relative; cursor: pointer; transition: background 0.1s; }
        .cell.act { background: rgba(255,255,255,0.1); }
        
        /* Pieces & Burst */
        .pce { position: absolute; inset: 15%; border-radius: 50%; pointer-events: none; }
        .stl { border: 2px dashed currentColor; opacity: 0.4; animation: pulse 1.5s infinite; }
        .opn { background: currentColor; box-shadow: 0 0 15px currentColor; }
        .ink-stain { position: absolute; inset: 0; opacity: 0.6; z-index: 1; } /* „Ç§„É≥„ÇØ„Å´„Çà„ÇãÊ±ö„Åó */
        
        @keyframes pulse { 0%,100% {opacity: 0.2;} 50% {opacity: 0.6;} }
        #fx { position: absolute; inset: 0; pointer-events: none; z-index: 100; }

        /* Controls */
        .ctrl { display: flex; justify-content: space-around; align-items: center; padding: 5px; font-size: 28px; }
        .sym { cursor: pointer; opacity: 0.7; transition: 0.2s; padding: 10px; }
        .sym:hover { opacity: 1; transform: scale(1.1); }
        .btn { padding: 16px 32px; border: 1px solid var(--text); background: transparent; color: inherit; cursor: pointer; font-family: inherit; font-size: 16px; letter-spacing: 4px; transition: 0.3s; }
        .btn:hover { background: var(--text); color: var(--bg); }
        
        /* Lobby */
        #lobby-container { flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center; gap:50px; text-align:center; }
        .blink-cursor::after { content: '_'; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* Menu Overlay */
        .menu-overlay { position: fixed; inset: 0; background: var(--ui); z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; gap: 25px; backdrop-filter: blur(5px); }
        .status-msg { font-size: 12px; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 10px; }
    </style>
</head>
<body>

<div id="scene-home" class="scene active">
    <div id="lobby-container">
        <h1 style="letter-spacing:18px; margin:0; font-weight:normal;">sub5conscious</h1>
        
        <div id="host-view" style="display:none; flex-direction:column; align-items:center; gap:25px;">
            <div class="status-msg blink-cursor">READY TO HOST</div>
            <button id="copy-btn" class="btn" onclick="NET.copyLink()">GENERATE ROOM URL</button>
            <p style="font-size:11px; opacity:0.5; max-width:300px; line-height:2;">
                Áõ∏Êâã„Å´URL„ÇíÈÄÅ„Çä„ÄÅ„Åì„ÅÆÁîªÈù¢„ÅÆ„Åæ„ÅæÂæÖÊ©ü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<br>Êé•Á∂ö„Åï„Çå„Çã„Å®Ëá™Âãï„ÅßÂÖàÊâã„ÅåÊ±∫ÂÆö„ÅóÈñãÂßã„Åó„Åæ„Åô„ÄÇ
            </p>
        </div>

        <div id="guest-view" style="display:none; flex-direction:column; align-items:center; gap:25px;">
            <div class="status-msg blink-cursor">CONNECTING</div>
            <p style="font-size:13px; letter-spacing:3px;">WAITING FOR HANDSHAKE</p>
        </div>
    </div>
</div>

<div id="scene-game" class="scene">
    <div class="ui-bar">
        <div class="timer-info">
            <span id="p2-label">OPPONENT</span>
            <span id="t2-val">--:-- [--]</span>
        </div>
        <div class="bar-track"><div id="f-p2" class="bar-fill"></div></div>
    </div>

    <div id="stage">
        <canvas id="fx"></canvas>
        <div id="grid"></div>
    </div>

    <div class="ui-bar">
        <div class="bar-track"><div id="f-p1" class="bar-fill"></div></div>
        <div class="timer-info">
            <span id="t1-val">--:-- [--]</span>
            <span id="turn-val">TURN 1</span>
        </div>
        <div class="ctrl">
            <div class="sym" title="Reset" onclick="GAME.resetReq()">‚ü≤</div>
            <div class="sym" title="Menu" onclick="APP.toggleMenu()">‚â°</div>
            <div class="sym" title="Home" onclick="APP.goHome()">‚åÇ</div>
        </div>
    </div>
</div>

<div id="menu" class="menu-overlay">
    <div style="text-align:center; border:1px solid #444; padding:40px; margin-bottom:10px;">
        <h2 style="margin-top:0; letter-spacing:5px; font-weight:normal;">SETTINGS</h2>
        <div style="display:grid; grid-template-columns: 140px 1fr; gap:20px; text-align:left; align-items:center;">
            <label>TIME (S):</label>
            <input type="number" id="cfg-t" value="300" style="width:80px; background:none; color:inherit; border:1px solid #666; padding:5px; font-family:inherit;">
            <label>BYO (S):</label>
            <input type="number" id="cfg-b" value="30" style="width:80px; background:none; color:inherit; border:1px solid #666; padding:5px; font-family:inherit;">
        </div>
    </div>
    <button class="btn" onclick="APP.theme()">DARK/LIGHT</button>
    <button class="btn" onclick="GAME.resignReq()">RESIGN (√ó)</button>
    <button class="btn" onclick="APP.toggleMenu()">RETURN (‚Üµ)</button>
</div>

<script>
/**
 * sub5conscious Ver 2.6 - Online P2P with Random Start
 */

const STATE = {
    board: [], p: 1, actions: [], history: [], winner: null,
    time: [300, 300], byo: [30, 30], isByo: [false, false],
    conf: { t: 300, b: 30 }, timerInt: null, inkData: []
};

const APP = {
    init() {
        FX.init();
        NET.init();
    },
    switch(id) {
        document.querySelectorAll('.scene').forEach(s => s.classList.remove('active'));
        document.getElementById('scene-' + id).classList.add('active');
    },
    toggleMenu() {
        const m = document.getElementById('menu');
        m.style.display = m.style.display === 'flex' ? 'none' : 'flex';
    },
    theme() {
        const b = document.body;
        b.dataset.theme = b.dataset.theme === 'light' ? 'dark' : 'light';
    },
    goHome() {
        if(confirm("LOBBY„Å´Êàª„Çä„Åæ„Åô„ÅãÔºüÁèæÂú®„ÅÆÈÄö‰ø°„ÅØÂàáÊñ≠„Åï„Çå„Åæ„Åô„ÄÇ")) {
            window.location.hash = '';
            location.reload();
        }
    }
};

const GAME = {
    start(p1IsHost, t, b) {
        STATE.board = Array.from({length: 64}, () => ({s:0, o:0}));
        STATE.inkData = Array(64).fill(null);
        STATE.p = 1; STATE.actions = []; STATE.winner = null; STATE.history = [];
        STATE.conf.t = t; STATE.conf.b = b;
        STATE.time = [t, t]; STATE.byo = [b, b];
        STATE.isByo = [false, false];

        // Ëá™ÂàÜ„ÅåPlayer 1„Åã„Å©„ÅÜ„Åã„ÇíÁ¢∫ÂÆö
        NET.myNum = (NET.role === 'HOST') ? (p1IsHost ? 1 : 2) : (p1IsHost ? 2 : 1);
        
        this.render();
        if(this.timerInt) clearInterval(this.timerInt);
        this.timerInt = setInterval(() => this.tick(), 100);
        APP.switch('game');
        
        // „É©„Éô„É´Êõ¥Êñ∞
        document.getElementById('p2-label').innerText = NET.myNum === 1 ? "PLAYER 2 (OPPONENT)" : "PLAYER 1 (OPPONENT)";
        document.getElementById('t2-val').style.color = NET.myNum === 1 ? 'var(--p2)' : 'var(--p1)';
        document.getElementById('t1-val').style.color = NET.myNum === 1 ? 'var(--p1)' : 'var(--p2)';
    },

    click(i) {
        if(STATE.winner || (STATE.p !== NET.myNum)) return;
        const cell = STATE.board[i];
        
        // Ë®≠Ë®àÊõ∏Ê∫ñÊã†: 1ÊâãÁõÆ„Ç≠„É£„É≥„Çª„É´„ÅÆÊåôÂãï
        if(cell.s === 2) { this.cancel(); return; }
        if(STATE.actions.length === 1) {
            const f = STATE.actions[0];
            const dist = Math.abs(Math.floor(i/8)-Math.floor(f/8)) + Math.abs((i%8)-(f%8));
            if(i !== f && dist !== 1) { this.cancel(); return; }
        }

        STATE.actions.push(i);
        NET.send({type:'act', i});
        this.render();
        if(STATE.actions.length === 2) this.resolve();
    },

    cancel() {
        STATE.actions = [];
        NET.send({type:'cancel'});
        this.render();
    },

    resolve() {
        const turnP = STATE.p;
        STATE.actions.forEach(idx => {
            const c = STATE.board[idx];
            if(c.s === 0) { c.s = 1; c.o = turnP; }
            else if(c.s === 1) { 
                c.s = 2; c.o = turnP; 
                FX.burst(idx, turnP); 
                STATE.inkData[idx] = turnP; // „Ç§„É≥„ÇØ„ÅßÊ±ö„ÅôË°®Áèæ
            }
        });

        STATE.history.push([...STATE.actions]);
        if(this.winCheck()) { this.end(turnP); return; }

        STATE.p = turnP === 1 ? 2 : 1;
        STATE.byo[turnP-1] = STATE.conf.b; 
        STATE.actions = [];
        this.render();
    },

    winCheck() {
        const b = STATE.board; const p = STATE.p;
        const dirs = [1, 8, 9, 7];
        for(let i=0; i<64; i++) {
            if(b[i].s===2 && b[i].o===p) {
                for(let d of dirs) {
                    let c=1;
                    for(let s=1; s<5; s++) {
                        let n = i+d*s;
                        if(n>=0 && n<64 && (n%8 >= i%8 || d!==7) && b[n].s===2 && b[n].o===p) c++; else break;
                    }
                    if(c>=5) return true;
                }
            }
        }
        return false;
    },

    tick() {
        const idx = STATE.p - 1;
        if(!STATE.isByo[idx]) {
            STATE.time[idx] -= 0.1;
            if(STATE.time[idx] <= 0) { STATE.time[idx] = 0; STATE.isByo[idx] = true; }
        } else {
            STATE.byo[idx] -= 0.1;
            if(STATE.byo[idx] <= 0) this.end(STATE.p===1?2:1, "TIME UP");
        }
        this.updateClockUI();
    },

    updateClockUI() {
        const fmt = (s) => {
            const m = Math.floor(s/60); const sec = Math.floor(s%60);
            return `${m}:${sec.toString().padStart(2,'0')}`;
        };
        const p1T = `${fmt(STATE.time[0])} [${Math.max(0, Math.ceil(STATE.byo[0]))}]`;
        const p2T = `${fmt(STATE.time[1])} [${Math.max(0, Math.ceil(STATE.byo[1]))}]`;
        
        const myIdx = NET.myNum - 1;
        const opIdx = myIdx === 0 ? 1 : 0;

        document.getElementById('t1-val').innerText = (NET.myNum === 1 ? p1T : p2T);
        document.getElementById('t2-val').innerText = (NET.myNum === 1 ? p2T : p1T);
        
        const f1 = document.getElementById('f-p1');
        const f2 = document.getElementById('f-p2');
        f1.style.width = (STATE.time[myIdx]/STATE.conf.t*100)+'%';
        f2.style.width = (STATE.time[opIdx]/STATE.conf.t*100)+'%';
        f1.style.background = STATE.time[myIdx] < 30 ? '#ff3300' : (NET.myNum === 1 ? 'var(--p1)' : 'var(--p2)');
        f2.style.background = STATE.time[opIdx] < 30 ? '#ff3300' : (NET.myNum === 1 ? 'var(--p2)' : 'var(--p1)');
    },

    render() {
        const g = document.getElementById('grid'); g.innerHTML = '';
        STATE.board.forEach((c, i) => {
            const d = document.createElement('div');
            d.className = 'cell' + (STATE.actions.includes(i) ? ' act' : '');
            if(STATE.inkData[i]) {
                d.style.background = STATE.inkData[i] === 1 ? 'rgba(0,255,255,0.08)' : 'rgba(255,0,255,0.08)';
            }
            d.onclick = () => this.click(i);
            if(c.s === 2) d.innerHTML = `<div class="pce opn" style="color:var(--p${c.o})"></div>`;
            else if(c.s === 1 && c.o === NET.myNum) d.innerHTML = `<div class="pce stl" style="color:var(--p${c.o})"></div>`;
            g.appendChild(d);
        });
        document.getElementById('turn-val').innerText = `TURN ${STATE.history.length + 1}`;
    },

    end(w, reason="") {
        STATE.winner = w; clearInterval(this.timerInt);
        const winColor = w === 1 ? "BLUE" : "MAGENTA";
        alert(`PLAYER ${w} (${winColor}) WINS! ${reason}`);
    },

    resignReq() { if(confirm("Êäï‰∫Ü„Åó„Åæ„Åô„ÅãÔºü")) { NET.send({type:'resign'}); this.end(NET.myNum===1?2:1, "(RESIGNED)"); APP.toggleMenu(); } },
    resetReq() { if(confirm("Ë®òÂè∑„ÅÆ„Åø„ÅÆÁ¢∫Ë™çÔºö‚ü≤Ôºü")) { NET.send({type:'reset_req'}); } }
};

const NET = {
    peer: null, conn: null, myNum: 1, role: 'HOST',
    init() {
        this.peer = new Peer();
        const hashId = window.location.hash.replace('#', '');

        this.peer.on('open', id => {
            if(hashId) {
                this.role = 'GUEST';
                document.getElementById('guest-view').style.display = 'flex';
                this.conn = this.peer.connect(hashId);
                this.setup();
            } else {
                this.role = 'HOST';
                this.myId = id;
                document.getElementById('host-view').style.display = 'flex';
            }
        });

        this.peer.on('connection', c => {
            if(this.role === 'HOST') {
                this.conn = c; this.setup();
                this.conn.on('open', () => {
                    // ÂÖàÊâã„ÅÆ„É©„É≥„ÉÄ„É†Ê±∫ÂÆö (Host„ÅåË®àÁÆó„Åó„Å¶Guest„Å∏ÈÄöÁü•)
                    const p1IsHost = Math.random() < 0.5;
                    const t = parseInt(document.getElementById('cfg-t').value);
                    const b = parseInt(document.getElementById('cfg-b').value);
                    this.send({type:'init', p1IsHost, t, b});
                    GAME.start(p1IsHost, t, b);
                });
            }
        });
    },
    copyLink() {
        const url = window.location.origin + window.location.pathname + '#' + this.myId;
        navigator.clipboard.writeText(url).then(() => {
            const b = document.getElementById('copy-btn');
            b.innerText = "URL COPIED";
            setTimeout(() => b.innerText = "GENERATE ROOM URL", 2000);
        });
    },
    setup() {
        this.conn.on('data', d => {
            if(d.type==='init') GAME.start(d.p1IsHost, d.t, d.b);
            if(d.type==='act') { STATE.actions.push(d.i); GAME.render(); if(STATE.actions.length===2) GAME.resolve(); }
            if(d.type==='cancel') GAME.cancel();
            if(d.type==='resign') GAME.end(this.myNum, "(OPPONENT RESIGNED)");
            if(d.type==='reset_req') { if(confirm("Áõ∏Êâã„Åã„Çâ„É™„Çª„ÉÉ„ÉàË¶ÅË´ã„ÄÇÂêåÊÑè„Åó„Åæ„Åô„ÅãÔºü")) { this.send({type:'reset_ok'}); GAME.start(NET.myNum===1, STATE.conf.t, STATE.conf.b); } }
            if(d.type==='reset_ok') GAME.start(NET.myNum===1, STATE.conf.t, STATE.conf.b);
        });
        this.conn.on('close', () => { alert("DISCONNECTED"); location.reload(); });
    },
    send(d) { if(this.conn && this.conn.open) this.conn.send(d); }
};

const FX = {
    pts: [],
    init() {
        const c = document.getElementById('fx'); const ctx = c.getContext('2d');
        const loop = () => {
            c.width = c.offsetWidth; c.height = c.offsetHeight;
            ctx.clearRect(0,0,c.width,c.height);
            this.pts.forEach((p,i) => {
                p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.l-=0.015;
                ctx.globalAlpha = Math.max(0, p.l); ctx.fillStyle = p.c;
                ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,7); ctx.fill();
                if(p.l<=0) this.pts.splice(i,1);
            });
            requestAnimationFrame(loop);
        };
        loop();
    },
    burst(i, p) {
        const r = document.getElementById('grid').getBoundingClientRect();
        const cw = r.width/8;
        const x = (i%8)*cw+cw/2; const y = Math.floor(i/8)*cw+cw/2;
        const color = p===1 ? 'cyan' : 'magenta';
        for(let n=0; n<50; n++) this.pts.push({
            x, y, vx:(Math.random()-0.5)*20, vy:(Math.random()-0.5)*20,
            l:1, s:Math.random()*6+1, c:color
        });
    }
};

APP.init();
</script>
</body>
</html>

R_1, // For online/AI (1 or 2)
    isGameOver: false,
    timer: { p1: 0, p2: 0, active: false },
    theme: 'light',
    devMode: false
};

// --- App Manager (UI & Flow) ---
const app = {
    init: () => {
        app.createBoard();
        app.applyTheme();
        network.initPeer();
    },

    createBoard: () => {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        state.board = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            const row = [];
            for (let c = 0; c < BOARD_SIZE; c++) {
                row.push({ owner: PLAYER_NONE, status: STATUS_EMPTY });
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.onclick = () => game.handleInput(r, c);
                
                const stone = document.createElement('div');
                stone.className = 'stone hidden'; // Start hidden
                cell.appendChild(stone);
                boardEl.appendChild(cell);
            }
            state.board.push(row);
        }
    },

    toggleTheme: () => {
        state.theme = state.theme === 'light' ? 'dark' : 'light';
        app.applyTheme();
    },

    applyTheme: () => {
        document.documentElement.setAttribute('data-theme', state.theme);
    },

    goHome: () => {
        document.getElementById('menu-overlay').classList.remove('hidden');
        document.getElementById('online-menu').classList.add('hidden');
        document.getElementById('game-end-modal').classList.add('hidden');
        game.resetGame(true); // Silent reset
    },

    startLocal: () => {
        state.mode = 'offline';
        state.myPlayerId = 0; // See all (or handled by turn logic)
        app.startGame();
    },

    startAI: () => {
        state.mode = 'ai';
        // Random first player
        state.myPlayerId = Math.random() < 0.5 ? PLAYER_1 : PLAYER_2;
        app.startGame();
        if (state.currentPlayer !== state.myPlayerId) {
            setTimeout(ai.makeMove, 1000);
        }
    },

    showOnlineMenu: () => {
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('online-menu').classList.remove('hidden');
    },

    startGame: () => {
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('online-menu').classList.add('hidden');
        document.getElementById('game-end-modal').classList.add('hidden');
        
        game.resetGame();
        
        // Random start logic for all modes (except forced logic)
        // Per user request: "Always start online matches with a random first player"
        // Core logic always starts P1, but we assign User to P1 or P2 randomly in Online/AI.
        
        app.updateUIControls();
        view.render();
    },

    updateUIControls: () => {
        const resetBtn = document.getElementById('btn-reset');
        const retireBtn = document.getElementById('btn-retire');
        
        if (state.mode === 'online') {
            resetBtn.classList.add('hidden');
            retireBtn.classList.remove('hidden');
        } else {
            resetBtn.classList.remove('hidden');
            retireBtn.classList.add('hidden');
        }
    },

    toggleOptions: () => document.getElementById('options-menu').classList.remove('hidden'),
    closeOptions: () => document.getElementById('options-menu').classList.add('hidden'),
    
    toggleDevMode: () => {
        state.devMode = !state.devMode;
        document.getElementById('dev-panel').style.display = state.devMode ? 'block' : 'none';
        app.closeOptions();
    },

    showAnalysis: () => {
        alert("Analysis Mode is a placeholder in this v1.0 version. \nDeveloper Mode allows Kifu download.");
    }
};

// --- Game Logic ---
const game = {
    resetGame: (silent = false) => {
        state.isGameOver = false;
        state.firstSelection = null;
        state.turnCount = 0;
        state.currentPlayer = PLAYER_1; // Logic always starts with P1 turn
        state.board.forEach(row => row.forEach(cell => {
            cell.owner = PLAYER_NONE;
            cell.status = STATUS_EMPTY;
        }));
        
        recorder.init();
        
        if (!silent) {
            view.updateStatus(`Game Start! Player ${state.currentPlayer}'s Turn`);
            view.render();
        }
    },

    handleInput: (r, c) => {
        if (state.isGameOver) return;
        
        // Online/AI check: can only move if it's my turn
        if (state.mode === 'online' && state.currentPlayer !== state.myPlayerId) return;
        if (state.mode === 'ai' && state.currentPlayer !== state.myPlayerId) return;

        const cell = state.board[r][c];

        // First Click (Selection)
        if (!state.firstSelection) {
            // Rule: Cannot select 'opened' cells for the first click
            if (cell.status === STATUS_OPENED) {
                // UI Feedback: Invalid move
                return; 
            }
            state.firstSelection = { r, c };
            view.render(); // Highlight selection
            return;
        }

        // Second Click (Commit)
        const fromR = state.firstSelection.r;
        const fromC = state.firstSelection.c;
        const dist = Math.abs(r - fromR) + Math.abs(c - fromC);

        let moveType = null;

        // Logic B: Focus (Same cell) -> Instant Open
        if (r === fromR && c === fromC) {
            moveType = 'focus';
        }
        // Logic A: Domino (Adjacent) -> Stealth placement/upgrade
        else if (dist === 1) {
            moveType = 'domino';
        } else {
            // Invalid second click, cancel selection
            state.firstSelection = null;
            view.render();
            return;
        }

        // Execute Move
        game.executeMove({
            player: state.currentPlayer,
            coords: [{r: fromR, c: fromC}, {r, c}],
            moveType: moveType,
            turnIndex: state.turnCount
        });

        // Send to network if online
        if (state.mode === 'online') {
            network.sendMove({
                type: 'MOVE',
                player: state.currentPlayer,
                coords: [{r: fromR, c: fromC}, {r, c}],
                moveType: moveType,
                turnIndex: state.turnCount
            });
        }
    },

    executeMove: (move) => {
        const { player, coords, moveType } = move;
        const target = coords[1]; // The target of the action (domino end or focus self)

        if (moveType === 'focus') {
            // Target becomes OPENED immediately
            const cell = state.board[target.r][target.c];
            cell.owner = player;
            cell.status = STATUS_OPENED;
        } else if (moveType === 'domino') {
            // Apply to BOTH cells (Source and Target)
            coords.forEach(coord => {
                const cell = state.board[coord.r][coord.c];
                // Rule: 
                // empty -> stealth (owner = current)
                // stealth -> opened (owner = current, overwrites previous)
                // opened -> invalid (already checked in logic, but safety here)
                
                if (cell.status === STATUS_EMPTY) {
                    cell.owner = player;
                    cell.status = STATUS_STEALTH;
                } else if (cell.status === STATUS_STEALTH) {
                    cell.owner = player;
                    cell.status = STATUS_OPENED;
                }
            });
        }

        recorder.addMove(move);
        state.firstSelection = null;
        view.render();
        
        // Check Win
        const win = game.checkWin();
        if (win) {
            game.endGame(win);
        } else {
            game.switchTurn();
        }
    },

    checkWin: () => {
        // Check only OPENED cells for Current Player
        const p = state.currentPlayer;
        const b = state.board;
        const dirs = [[0,1], [1,0], [1,1], [1,-1]]; // Horizontal, Vertical, Diag, Anti-Diag

        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (b[r][c].owner !== p || b[r][c].status !== STATUS_OPENED) continue;

                for (let d of dirs) {
                    let count = 1;
                    let line = [{r,c}];
                    // Check forward
                    for (let i = 1; i < 5; i++) {
                        let nr = r + d[0]*i, nc = c + d[1]*i;
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                        if (b[nr][nc].owner === p && b[nr][nc].status === STATUS_OPENED) {
                            count++;
                            line.push({r: nr, c: nc});
                        } else break;
                    }
                    if (count >= 5) return { winner: p, line: line };
                }
            }
        }
        return null;
    },

    switchTurn: () => {
        state.turnCount++;
        state.currentPlayer = state.currentPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;
        view.updateStatus(`Player ${state.currentPlayer}'s Turn`);
        
        if (state.mode === 'ai' && state.currentPlayer !== state.myPlayerId) {
            setTimeout(ai.makeMove, 1000);
        }
    },

    endGame: (result) => {
        state.isGameOver = true;
        view.highlightWin(result.line);
        const msg = `Player ${result.winner} Wins!`;
        view.updateStatus(msg);
        
        setTimeout(() => {
            document.getElementById('end-reason').innerText = msg;
            document.getElementById('game-end-modal').classList.remove('hidden');
            
            if (state.mode === 'online') {
                document.getElementById('online-end-controls').classList.remove('hidden');
                document.getElementByI        button.primary { background: var(--accent); border: none; }
        
        #pass-overlay { background: #000; color: #fff; text-align: center; }
        #top-controls { position: fixed; bottom: 25px; right: 25px; display: flex; gap: 15px; z-index: 2000; }
        .ctrl-btn { width: 55px; height: 55px; background: var(--panel); border: 1px solid var(--border); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 5px 15px rgba(0,0,0,0.4); font-size: 1.5rem; }

        @keyframes winAnim { 0%,100%{transform:scale(1);} 50%{transform:scale(1.2); filter:brightness(1.3);} }
        .win-token { animation: winAnim 0.6s infinite; z-index: 10; }
    </style>
</head>
<body>

    <div id="header">
        <div id="status-msg">READY</div>
        <div class="timer-bar">
            <div id="p1-ui" class="p-box active">P1 <span id="p1-t">10:00</span></div>
            <div id="p2-ui" class="p-box">P2 <span id="p2-t">10:00</span></div>
        </div>
    </div>

    <div id="board-area"><div id="board"></div></div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h1 style="font-size: 2.8rem; margin-bottom: 40px; letter-spacing: -2px;">sub5conscious</h1>
        <div class="section">
            <button class="primary" onclick="setupGame('offline')">2P OFFLINE</button>
            <button class="primary" onclick="setupGame('ai')">VS LEARNING AI</button>
            <button class="primary" onclick="showOnlineSetup()">ONLINE MATCH</button>
        </div>
        <button onclick="showLogs()" style="opacity:0.6; border:none; font-size:0.8rem;">ANALYTICS & LOG</button>
    </div>

    <div id="pass-overlay" class="overlay">
        <h1 id="pass-player-name">PLAYER 2 TURN</h1>
        <p style="opacity:0.5;">Please pass the device</p>
        <button onclick="resumeFromPass()" style="background:#fff; color:#000; width:220px; margin-top:40px; border-radius:50px;">I RECEIVED IT</button>
    </div>

    <div id="settings-overlay" class="overlay">
        <h2>OPTIONS</h2>
        <div class="section">
            <label style="font-size:0.7rem;">TIMER (MIN / BYOYOMI)</label>
            <div style="display:flex; gap:10px; margin-top:5px;">
                <input type="number" id="cfg-min" value="10" style="width:50%; padding:10px; background:#0f172a; color:#fff; border:1px solid var(--border);">
                <input type="number" id="cfg-byo" value="30" style="width:50%; padding:10px; background:#0f172a; color:#fff; border:1px solid var(--border);">
            </div>
            <button class="primary" onclick="applySettings()" style="margin-top:15px;">APPLY & RESET</button>
        </div>
        <button onclick="closeOverlays()">CLOSE</button>
    </div>

    <div id="online-overlay" class="overlay">
        <h2>ONLINE CONNECT</h2>
        <div class="section">
            <input type="text" id="match-kw" placeholder="KEYWORD" style="width:100%; padding:15px; background:#0f172a; border:1px solid var(--border); color:#fff; border-radius:8px;">
            <button class="primary" onclick="connectOnline()" style="margin-top:15px;">CONNECT</button>
        </div>
        <button onclick="closeOverlays()">BACK</button>
    </div>

    <div id="top-controls">
        <div class="ctrl-btn" onclick="handleReset()">üîÑ</div>
        <div class="ctrl-btn" onclick="openSettings()">‚â°</div>
    </div>

    <script>
        // --- Core Setup ---
        const firebaseConfig = {
            apiKey: "AIzaSyAIkCvmJVZE9qzeAPFTIEijsuZ_HGRiUlA",
            authDomain: "sub5conscious.firebaseapp.com",
            projectId: "sub5conscious",
            databaseURL: "https://sub5conscious-default-rtdb.firebaseio.com",
            storageBucket: "sub5conscious.firebasestorage.app",
            messagingSenderId: "774659474330",
            appId: "1:774659474330:web:d1ff3843a96f6e6001b023"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let SIZE = 8, board = [], currentPlayer = 1, winLine = null, moveHistory = [];
        let p1Time = 600, p2Time = 600, p1Byo = 30, p2Byo = 30, configMin = 10, configByo = 30;
        let timerId = null, mode = 'offline', myId = 1, firstSelect = null, isPassing = false, dbRef = null;
        let learnedData = [];

        // --- Game Logic ---
        async function setupGame(m) {
            mode = m;
            document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
            if(mode === 'ai') await loadAIKnowledge();
            initBoard();
        }

        async function loadAIKnowledge() {
            const snap = await db.ref('game_logs').limitToLast(30).once('value');
            learnedData = [];
            snap.forEach(s => { if(s.val().history) learnedData.push(...s.val().history); });
        }

        function initBoard() {
            clearInterval(timerId);
            board = Array.from({length:SIZE}, () => Array(SIZE).fill(null).map(() => ({p:0, open:false})));
            currentPlayer = 1; winLine = null; firstSelect = null; isPassing = false; moveHistory = [];
            p1Time = configMin * 60; p2Time = p1Time; p1Byo = configByo; p2Byo = configByo;
            
            const grid = document.getElementById('board');
            grid.innerHTML = '';
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => handleCellClick(r, c);
                    let t = document.createElement('div'); t.className = 'token';
                    cell.appendChild(t); grid.appendChild(cell);
                }
            }
            startTimer();
            updateUI();
        }

        function handleCellClick(r, c) {
            if(winLine || isPassing || board[r][c].open) return;
            if(mode === 'online' && currentPlayer !== myId) return;

            if(!firstSelect) {
                firstSelect = {r, c};
            } else {
                // „ÄêÊ©üËÉΩ4Ôºö„Ç≠„É£„É≥„Çª„É´Ë™øÊï¥„ÄëÂêå„Åò„Éû„Çπ„ÇíÂè©„ÅÑ„Åü„ÇâËß£Èô§
                if(firstSelect.r === r && firstSelect.c === c) {
                    firstSelect = null;
                } else {
                    let dr = Math.abs(r - firstSelect.r), dc = Math.abs(c - firstSelect.c);
                    if(dr === 0 && dc === 0) commit([{r, c, open: true}]);
                    else if(dr + dc === 1) commit([{r: firstSelect.r, c: firstSelect.c, open: false}, {r, c, open: false}]);
                    else firstSelect = {r, c};
                }
            }
            updateUI();
        }

        function commit(moves) {
            moves.forEach(m => {
                let cell = board[m.r][m.c];
                if(cell.p !== 0 || m.open) cell.open = true;
                cell.p = currentPlayer;
                moveHistory.push({r: m.r, c: m.c, p: currentPlayer});
            });

            if(checkWin(currentPlayer)) {
                endGame(`PLAYER ${currentPlayer} WIN!`);
            } else {
                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                firstSelect = null;
                if(mode === 'offline') {
                    isPassing = true;
                    document.getElementById('pass-overlay').style.display = 'flex';
                    document.getElementById('pass-player-name').innerText = `PLAYER ${currentPlayer} TURN`;
                } else if(mode === 'ai' && currentPlayer === 2) {
                    setTimeout(executeAIMove, 600);
                } else if(mode === 'online') {
                    syncOnline();
                }
            }
            updateUI();
        }

        function executeAIMove() {
            // „ÄêÊ©üËÉΩ5ÔºöÂ≠¶ÁøíÂûãAI„ÄëÈÅéÂéª„Éá„Éº„Çø„Å´Âü∫„Å•„Åç„Çπ„Ç≥„Ç¢„É™„É≥„Ç∞
            let candidates = [];
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    if(!board[r][c].open) {
                        let weight = learnedData.filter(d => d.r === r && d.c === c).length;
                        candidates.push({r, c, w: weight + Math.random()});
                    }
                }
            }
            candidates.sort((a,b) => b.w - a.w);
            let m1 = candidates[0];
            let m2 = candidates.find(c => Math.abs(c.r-m1.r)+Math.abs(c.r-m1.c) === 1) || candidates[1];
            commit([{r: m1.r, c: m1.c, open:false}, {r: m2.r, c: m2.c, open:false}]);
        }

        function checkWin(p) {
            const dirs = [[1,0],[0,1],[1,1],[1,-1]];
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    if(board[r][c].p === p && board[r][c].open) {
                        for(let [dr,dc] of dirs) {
                            let line = [];
                            for(let i=0; i<5; i++) {
                                let nr=r+dr*i, nc=c+dc*i;
                                if(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&board[nr][nc].p===p&&board[nr][nc].open) line.push({r:nr,c:nc});
                                else break;
                            }
                            if(line.length === 5) { winLine = line; return true; }
                        }
                    }
                }
            }
            return false;
        }

        function updateUI() {
            const tokens = document.querySelectorAll('.token');
            const cells = document.querySelectorAll('.cell');
            board.flat().forEach((cell, i) => {
                let t = tokens[i];
                t.style.backgroundColor = cell.p === 1 ? 'var(--p1)' : 'var(--p2)';
                let isMe = (mode === 'offline' && !isPassing && cell.p === currentPlayer) || (mode === 'ai' && cell.p === 1) || (mode === 'online' && cell.p === myId);
                
                // „ÄêÊ©üËÉΩ3ÔºöÂÖ®ÂÖ¨Èñã„É™„Éó„É¨„Ç§„ÄëÂãùÂà©ÊôÇ„ÅØÂÖ®Èßí„Ç™„Éº„Éó„É≥
                if(cell.open || winLine) t.className = 'token show opened';
                else if(isMe && cell.p !== 0) t.className = 'token show stealth';
                else t.className = 'token';

                if(winLine && winLine.some(l => l.r === Math.floor(i/SIZE) && l.c === i%SIZE)) t.classList.add('win-token');
                
                let r = Math.floor(i/SIZE), c = i%SIZE;
                cells[i].style.background = (firstSelect && firstSelect.r===r && firstSelect.c===c) ? 'rgba(59, 130, 246, 0.2)' : 'var(--panel)';
            });
            document.getElementById('p1-ui').classList.toggle('active', currentPlayer===1);
            document.getElementById('p2-ui').classList.toggle('active', currentPlayer===2);
            document.getElementById('status-msg').innerText = winLine ? "GAME OVER" : `TURN: P${currentPlayer}`;
        }

        function startTimer() {
            timerId = setInterval(() => {
                if(winLine || isPassing) return;
                if(currentPlayer === 1) { if(p1Time > 0) p1Time--; else p1Byo--; if(p1Byo<0) endGame("P2 WIN (TIME)"); }
                else { if(p2Time > 0) p2Time--; else p2Byo--; if(p2Byo<0) endGame("P1 WIN (TIME)"); }
                const f = (t, b) => `${Math.floor(t/60)}:${(t%60).toString().padStart(2,'0')}${t<=0?` (${b})`:''}`;
                document.getElementById('p1-t').innerText = f(p1Time, p1Byo);
                document.getElementById('p2-t').innerText = f(p2Time, p2Byo);
            }, 1000);
        }

        function endGame(m) {
            clearInterval(timerId);
            updateUI();
            db.ref('game_logs').push({winner: currentPlayer, history: moveHistory, date: Date.now()});
            setTimeout(() => { alert(m); location.reload(); }, 1200);
        }

        // --- Utils ---
        function resumeFromPass() { isPassing = false; document.getElementById('pass-overlay').style.display = 'none'; updateUI(); }
        function openSettings() { document.getElementById('settings-overlay').style.display = 'flex'; }
        function applySettings() {
            configMin = parseInt(document.getElementById('cfg-min').value) || 10;
            configByo = parseInt(document.getElementById('cfg-byo').value) || 30;
            initBoard(); closeOverlays();
        }
        function showOnlineSetup() { document.getElementById('online-overlay').style.display = 'flex'; }
        function connectOnline() {
            const kw = document.getElementById('match-kw').value.trim();
            if(!kw) return;
            dbRef = db.ref('rooms/' + kw);
            dbRef.get().then(snap => {
                myId = snap.exists() ? 2 : 1;
                dbRef.on('value', s => {
                    const d = s.val(); if(!d) return;
                    board = d.board; currentPlayer = d.turn;
                    if(d.win) endGame(`PLAYER ${currentPlayer===1?2:1} WIN!`);
                    updateUI();
                });
                setupGame('online');
            });
        }
        function syncOnline() { if(dbRef) dbRef.set({ board, turn: currentPlayer, win: !!winLine }); }
        function closeOverlays() { document.querySelectorAll('.overlay').forEach(o => { if(o.id !== 'menu-overlay') o.style.display = 'none'; }); }
        function handleReset() { if(confirm("RESET GAME?")) location.reload(); }
        function showLogs() {
            db.ref('game_logs').limitToLast(5).once('value', s => {
                let str = "RECENT RESULTS:\n";
                s.forEach(i => { str += `> P${i.val().winner} WON (${new Date(i.val().date).toLocaleDateString()})\n`; });
                alert(str || "No data yet.");
            });
        }
    </script>
</body>
</html>
