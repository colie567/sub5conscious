<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sub5conscious</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --text-color: #333;
            --board-bg: #dcb35c;
            --cell-border: #b58868;
            --p1-color: #000;
            --p2-color: #fff;
            --highlight: rgba(0, 255, 0, 0.4);
            --win-line: rgba(255, 0, 0, 0.7);
            --panel-bg: rgba(255,255,255,0.9);
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --board-bg: #8b6d3e;
            --cell-border: #5c4033;
            --panel-bg: rgba(30,30,30,0.9);
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
            overflow: hidden; /* Prevent scroll on mobile */
        }

        /* --- Header & Controls --- */
        #top-bar {
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: var(--panel-bg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            background: #4a90e2;
            color: white;
            transition: 0.2s;
            margin-left: 5px;
        }
        .btn:hover { opacity: 0.9; }
        .btn-danger { background: #e74c3c; }
        .btn-secondary { background: #95a5a6; }

        /* --- Status Display (Top Center) --- */
        #game-status {
            position: absolute;
            top: 60px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 20;
            height: 40px;
        }

        /* --- Main Game Area --- */
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            position: relative;
            width: 100%;
            max-width: 600px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vmin;
            height: 90vmin;
            max-width: 500px;
            max-height: 500px;
            background-color: var(--board-bg);
            border: 5px solid var(--cell-border);
            position: relative;
        }

        .cell {
            border: 1px solid var(--cell-border);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 2px 2px 2px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }

        /* Cell Status Styles */
        .stone.p1 { background-color: var(--p1-color); }
        .stone.p2 { background-color: var(--p2-color); }
        
        /* Stealth vs Opened */
        .stone.stealth { opacity: 0.3; } /* Visible to owner */
        .stone.opened { opacity: 1.0; border: 2px solid gold; }
        .stone.hidden { display: none; } /* Hidden from opponent */

        .cell.selected { background-color: var(--highlight); }
        .cell.last-move { box-shadow: inset 0 0 10px rgba(0,0,255,0.5); }

        /* Win Line Animation */
        .win-line-cell {
            background-color: rgba(255, 215, 0, 0.6) !important;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* --- Overlays & Modals --- */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
        }
        .modal-content {
            background: var(--bg-color);
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .hidden { display: none !important; }

        .form-group { margin: 10px 0; text-align: left; }
        label { display: block; margin-bottom: 5px; }
        input, select { width: 100%; padding: 8px; box-sizing: border-box; }

        /* Developer Mode & Analysis */
        #dev-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            width: 100%;
            box-sizing: border-box;
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div>
            <button class="btn" onclick="app.goHome()">HOME</button>
            <button class="btn btn-secondary" onclick="app.toggleOptions()">Options</button>
        </div>
        <div>
            <button id="btn-reset" class="btn btn-danger hidden" onclick="game.resetGame()">Reset</button>
            <button id="btn-retire" class="btn btn-danger hidden" onclick="game.retire()">Retire</button>
        </div>
    </div>

    <div id="game-status"></div>

    <div id="game-container">
        <div id="board">
            </div>
    </div>

    <div id="menu-overlay" class="modal">
        <div class="modal-content">
            <h2>sub5conscious</h2>
            <p>ÊΩúÂú®ÁöÑ‰∫îÁõÆ - Potential Gomoku</p>
            <button class="btn" style="width:100%; margin:5px 0;" onclick="app.startLocal()">Offline (2P)</button>
            <button class="btn" style="width:100%; margin:5px 0;" onclick="app.startAI()">Vs AI (CPU)</button>
            <button class="btn" style="width:100%; margin:5px 0;" onclick="app.showOnlineMenu()">Online (P2P)</button>
            <button class="btn btn-secondary" style="width:100%; margin:5px 0;" onclick="app.showAnalysis()">Analysis Mode</button>
        </div>
    </div>

    <div id="online-menu" class="modal hidden">
        <div class="modal-content">
            <h3>Online Match</h3>
            <div class="form-group">
                <label>Room Password (ID)</label>
                <input type="text" id="room-id" placeholder="Enter same ID to match">
            </div>
            <button class="btn" onclick="network.hostGame()">Create/Join Room</button>
            <button class="btn btn-secondary" onclick="app.goHome()">Cancel</button>
            <p id="online-status" style="font-size: 0.8em; margin-top:10px; color: #888;">Connecting to server...</p>
        </div>
    </div>

    <div id="options-menu" class="modal hidden">
        <div class="modal-content">
            <h3>Options</h3>
            <div class="form-group">
                <label>Theme</label>
                <button class="btn btn-secondary" onclick="app.toggleTheme()">Toggle Dark/Light</button>
            </div>
            <div class="form-group">
                <label>Timer</label>
                <select id="timer-setting">
                    <option value="0">No Timer</option>
                    <option value="300">5 Minutes</option>
                    <option value="600">10 Minutes</option>
                </select>
            </div>
            <div class="form-group">
                <label>Developer Mode</label>
                <button class="btn btn-secondary" onclick="app.toggleDevMode()">Toggle Dev Mode</button>
            </div>
            <button class="btn" onclick="app.closeOptions()">Close</button>
        </div>
    </div>

    <div id="game-end-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="end-reason">Winner!</h2>
            <div id="online-end-controls" class="hidden">
                <button class="btn" onclick="network.requestRematch()">Rematch</button>
                <button class="btn btn-danger" onclick="network.disconnect()">Retire/Exit</button>
            </div>
            <div id="offline-end-controls">
                <button class="btn" onclick="game.resetGame()">Play Again</button>
                <button class="btn btn-secondary" onclick="app.goHome()">Home</button>
            </div>
        </div>
    </div>

    <div id="dev-panel">
        <strong>DEVELOPER MODE</strong>
        <button onclick="recorder.downloadKifu()">Download Kifu (JSON)</button>
        <button onclick="ai.enhanceWithGemini()">Enhance AI (Gemini)</button>
        <span id="dev-status">Ready.</span>
    </div>

<script>
/**
 * sub5conscious - Core Logic
 */

// --- Constants & Config ---
const BOARD_SIZE = 8;
const PLAYER_NONE = 0;
const PLAYER_1 = 1;
const PLAYER_2 = 2;

const STATUS_EMPTY = 'empty';
const STATUS_STEALTH = 'stealth';
const STATUS_OPENED = 'opened';

// --- Global State ---
const state = {
    board: [], // 8x8 array of { owner, status }
    currentPlayer: PLAYER_1,
    turnCount: 0,
    firstSelection: null, // {r, c}
    mode: 'offline', // 'offline', 'ai', 'online', 'analysis'
    myPlayerId: PLAYER_1, // For online/AI (1 or 2)
    isGameOver: false,
    timer: { p1: 0, p2: 0, active: false },
    theme: 'light',
    devMode: false
};

// --- App Manager (UI & Flow) ---
const app = {
    init: () => {
        app.createBoard();
        app.applyTheme();
        network.initPeer();
    },

    createBoard: () => {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        state.board = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            const row = [];
            for (let c = 0; c < BOARD_SIZE; c++) {
                row.push({ owner: PLAYER_NONE, status: STATUS_EMPTY });
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.onclick = () => game.handleInput(r, c);
                
                const stone = document.createElement('div');
                stone.className = 'stone hidden'; // Start hidden
                cell.appendChild(stone);
                boardEl.appendChild(cell);
            }
            state.board.push(row);
        }
    },

    toggleTheme: () => {
        state.theme = state.theme === 'light' ? 'dark' : 'light';
        app.applyTheme();
    },

    applyTheme: () => {
        document.documentElement.setAttribute('data-theme', state.theme);
    },

    goHome: () => {
        document.getElementById('menu-overlay').classList.remove('hidden');
        document.getElementById('online-menu').classList.add('hidden');
        document.getElementById('game-end-modal').classList.add('hidden');
        game.resetGame(true); // Silent reset
    },

    startLocal: () => {
        state.mode = 'offline';
        state.myPlayerId = 0; // See all (or handled by turn logic)
        app.startGame();
    },

    startAI: () => {
        state.mode = 'ai';
        // Random first player
        state.myPlayerId = Math.random() < 0.5 ? PLAYER_1 : PLAYER_2;
        app.startGame();
        if (state.currentPlayer !== state.myPlayerId) {
            setTimeout(ai.makeMove, 1000);
        }
    },

    showOnlineMenu: () => {
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('online-menu').classList.remove('hidden');
    },

    startGame: () => {
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('online-menu').classList.add('hidden');
        document.getElementById('game-end-modal').classList.add('hidden');
        
        game.resetGame();
        
        // Random start logic for all modes (except forced logic)
        // Per user request: "Always start online matches with a random first player"
        // Core logic always starts P1, but we assign User to P1 or P2 randomly in Online/AI.
        
        app.updateUIControls();
        view.render();
    },

    updateUIControls: () => {
        const resetBtn = document.getElementById('btn-reset');
        const retireBtn = document.getElementById('btn-retire');
        
        if (state.mode === 'online') {
            resetBtn.classList.add('hidden');
            retireBtn.classList.remove('hidden');
        } else {
            resetBtn.classList.remove('hidden');
            retireBtn.classList.add('hidden');
        }
    },

    toggleOptions: () => document.getElementById('options-menu').classList.remove('hidden'),
    closeOptions: () => document.getElementById('options-menu').classList.add('hidden'),
    
    toggleDevMode: () => {
        state.devMode = !state.devMode;
        document.getElementById('dev-panel').style.display = state.devMode ? 'block' : 'none';
        app.closeOptions();
    },

    showAnalysis: () => {
        alert("Analysis Mode is a placeholder in this v1.0 version. \nDeveloper Mode allows Kifu download.");
    }
};

// --- Game Logic ---
const game = {
    resetGame: (silent = false) => {
        state.isGameOver = false;
        state.firstSelection = null;
        state.turnCount = 0;
        state.currentPlayer = PLAYER_1; // Logic always starts with P1 turn
        state.board.forEach(row => row.forEach(cell => {
            cell.owner = PLAYER_NONE;
            cell.status = STATUS_EMPTY;
        }));
        
        recorder.init();
        
        if (!silent) {
            view.updateStatus(`Game Start! Player ${state.currentPlayer}'s Turn`);
            view.render();
        }
    },

    handleInput: (r, c) => {
        if (state.isGameOver) return;
        
        // Online/AI check: can only move if it's my turn
        if (state.mode === 'online' && state.currentPlayer !== state.myPlayerId) return;
        if (state.mode === 'ai' && state.currentPlayer !== state.myPlayerId) return;

        const cell = state.board[r][c];

        // First Click (Selection)
        if (!state.firstSelection) {
            // Rule: Cannot select 'opened' cells for the first click
            if (cell.status === STATUS_OPENED) {
                // UI Feedback: Invalid move
                return; 
            }
            state.firstSelection = { r, c };
            view.render(); // Highlight selection
            return;
        }

        // Second Click (Commit)
        const fromR = state.firstSelection.r;
        const fromC = state.firstSelection.c;
        const dist = Math.abs(r - fromR) + Math.abs(c - fromC);

        let moveType = null;

        // Logic B: Focus (Same cell) -> Instant Open
        if (r === fromR && c === fromC) {
            moveType = 'focus';
        }
        // Logic A: Domino (Adjacent) -> Stealth placement/upgrade
        else if (dist === 1) {
            moveType = 'domino';
        } else {
            // Invalid second click, cancel selection
            state.firstSelection = null;
            view.render();
            return;
        }

        // Execute Move
        game.executeMove({
            player: state.currentPlayer,
            coords: [{r: fromR, c: fromC}, {r, c}],
            moveType: moveType,
            turnIndex: state.turnCount
        });

        // Send to network if online
        if (state.mode === 'online') {
            network.sendMove({
                type: 'MOVE',
                player: state.currentPlayer,
                coords: [{r: fromR, c: fromC}, {r, c}],
                moveType: moveType,
                turnIndex: state.turnCount
            });
        }
    },

    executeMove: (move) => {
        const { player, coords, moveType } = move;
        const target = coords[1]; // The target of the action (domino end or focus self)

        if (moveType === 'focus') {
            // Target becomes OPENED immediately
            const cell = state.board[target.r][target.c];
            cell.owner = player;
            cell.status = STATUS_OPENED;
        } else if (moveType === 'domino') {
            // Apply to BOTH cells (Source and Target)
            coords.forEach(coord => {
                const cell = state.board[coord.r][coord.c];
                // Rule: 
                // empty -> stealth (owner = current)
                // stealth -> opened (owner = current, overwrites previous)
                // opened -> invalid (already checked in logic, but safety here)
                
                if (cell.status === STATUS_EMPTY) {
                    cell.owner = player;
                    cell.status = STATUS_STEALTH;
                } else if (cell.status === STATUS_STEALTH) {
                    cell.owner = player;
                    cell.status = STATUS_OPENED;
                }
            });
        }

        recorder.addMove(move);
        state.firstSelection = null;
        view.render();
        
        // Check Win
        const win = game.checkWin();
        if (win) {
            game.endGame(win);
        } else {
            game.switchTurn();
        }
    },

    checkWin: () => {
        // Check only OPENED cells for Current Player
        const p = state.currentPlayer;
        const b = state.board;
        const dirs = [[0,1], [1,0], [1,1], [1,-1]]; // Horizontal, Vertical, Diag, Anti-Diag

        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (b[r][c].owner !== p || b[r][c].status !== STATUS_OPENED) continue;

                for (let d of dirs) {
                    let count = 1;
                    let line = [{r,c}];
                    // Check forward
                    for (let i = 1; i < 5; i++) {
                        let nr = r + d[0]*i, nc = c + d[1]*i;
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                        if (b[nr][nc].owner === p && b[nr][nc].status === STATUS_OPENED) {
                            count++;
                            line.push({r: nr, c: nc});
                        } else break;
                    }
                    if (count >= 5) return { winner: p, line: line };
                }
            }
        }
        return null;
    },

    switchTurn: () => {
        state.turnCount++;
        state.currentPlayer = state.currentPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;
        view.updateStatus(`Player ${state.currentPlayer}'s Turn`);
        
        if (state.mode === 'ai' && state.currentPlayer !== state.myPlayerId) {
            setTimeout(ai.makeMove, 1000);
        }
    },

    endGame: (result) => {
        state.isGameOver = true;
        view.highlightWin(result.line);
        const msg = `Player ${result.winner} Wins!`;
        view.updateStatus(msg);
        
        setTimeout(() => {
            document.getElementById('end-reason').innerText = msg;
            document.getElementById('game-end-modal').classList.remove('hidden');
            
            if (state.mode === 'online') {
                document.getElementById('online-end-controls').classList.remove('hidden');
                document.getElementByI        button.primary { background: var(--accent); border: none; }
        
        #pass-overlay { background: #000; color: #fff; text-align: center; }
        #top-controls { position: fixed; bottom: 25px; right: 25px; display: flex; gap: 15px; z-index: 2000; }
        .ctrl-btn { width: 55px; height: 55px; background: var(--panel); border: 1px solid var(--border); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 5px 15px rgba(0,0,0,0.4); font-size: 1.5rem; }

        @keyframes winAnim { 0%,100%{transform:scale(1);} 50%{transform:scale(1.2); filter:brightness(1.3);} }
        .win-token { animation: winAnim 0.6s infinite; z-index: 10; }
    </style>
</head>
<body>

    <div id="header">
        <div id="status-msg">READY</div>
        <div class="timer-bar">
            <div id="p1-ui" class="p-box active">P1 <span id="p1-t">10:00</span></div>
            <div id="p2-ui" class="p-box">P2 <span id="p2-t">10:00</span></div>
        </div>
    </div>

    <div id="board-area"><div id="board"></div></div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h1 style="font-size: 2.8rem; margin-bottom: 40px; letter-spacing: -2px;">sub5conscious</h1>
        <div class="section">
            <button class="primary" onclick="setupGame('offline')">2P OFFLINE</button>
            <button class="primary" onclick="setupGame('ai')">VS LEARNING AI</button>
            <button class="primary" onclick="showOnlineSetup()">ONLINE MATCH</button>
        </div>
        <button onclick="showLogs()" style="opacity:0.6; border:none; font-size:0.8rem;">ANALYTICS & LOG</button>
    </div>

    <div id="pass-overlay" class="overlay">
        <h1 id="pass-player-name">PLAYER 2 TURN</h1>
        <p style="opacity:0.5;">Please pass the device</p>
        <button onclick="resumeFromPass()" style="background:#fff; color:#000; width:220px; margin-top:40px; border-radius:50px;">I RECEIVED IT</button>
    </div>

    <div id="settings-overlay" class="overlay">
        <h2>OPTIONS</h2>
        <div class="section">
            <label style="font-size:0.7rem;">TIMER (MIN / BYOYOMI)</label>
            <div style="display:flex; gap:10px; margin-top:5px;">
                <input type="number" id="cfg-min" value="10" style="width:50%; padding:10px; background:#0f172a; color:#fff; border:1px solid var(--border);">
                <input type="number" id="cfg-byo" value="30" style="width:50%; padding:10px; background:#0f172a; color:#fff; border:1px solid var(--border);">
            </div>
            <button class="primary" onclick="applySettings()" style="margin-top:15px;">APPLY & RESET</button>
        </div>
        <button onclick="closeOverlays()">CLOSE</button>
    </div>

    <div id="online-overlay" class="overlay">
        <h2>ONLINE CONNECT</h2>
        <div class="section">
            <input type="text" id="match-kw" placeholder="KEYWORD" style="width:100%; padding:15px; background:#0f172a; border:1px solid var(--border); color:#fff; border-radius:8px;">
            <button class="primary" onclick="connectOnline()" style="margin-top:15px;">CONNECT</button>
        </div>
        <button onclick="closeOverlays()">BACK</button>
    </div>

    <div id="top-controls">
        <div class="ctrl-btn" onclick="handleReset()">üîÑ</div>
        <div class="ctrl-btn" onclick="openSettings()">‚â°</div>
    </div>

    <script>
        // --- Core Setup ---
        const firebaseConfig = {
            apiKey: "AIzaSyAIkCvmJVZE9qzeAPFTIEijsuZ_HGRiUlA",
            authDomain: "sub5conscious.firebaseapp.com",
            projectId: "sub5conscious",
            databaseURL: "https://sub5conscious-default-rtdb.firebaseio.com",
            storageBucket: "sub5conscious.firebasestorage.app",
            messagingSenderId: "774659474330",
            appId: "1:774659474330:web:d1ff3843a96f6e6001b023"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let SIZE = 8, board = [], currentPlayer = 1, winLine = null, moveHistory = [];
        let p1Time = 600, p2Time = 600, p1Byo = 30, p2Byo = 30, configMin = 10, configByo = 30;
        let timerId = null, mode = 'offline', myId = 1, firstSelect = null, isPassing = false, dbRef = null;
        let learnedData = [];

        // --- Game Logic ---
        async function setupGame(m) {
            mode = m;
            document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
            if(mode === 'ai') await loadAIKnowledge();
            initBoard();
        }

        async function loadAIKnowledge() {
            const snap = await db.ref('game_logs').limitToLast(30).once('value');
            learnedData = [];
            snap.forEach(s => { if(s.val().history) learnedData.push(...s.val().history); });
        }

        function initBoard() {
            clearInterval(timerId);
            board = Array.from({length:SIZE}, () => Array(SIZE).fill(null).map(() => ({p:0, open:false})));
            currentPlayer = 1; winLine = null; firstSelect = null; isPassing = false; moveHistory = [];
            p1Time = configMin * 60; p2Time = p1Time; p1Byo = configByo; p2Byo = configByo;
            
            const grid = document.getElementById('board');
            grid.innerHTML = '';
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => handleCellClick(r, c);
                    let t = document.createElement('div'); t.className = 'token';
                    cell.appendChild(t); grid.appendChild(cell);
                }
            }
            startTimer();
            updateUI();
        }

        function handleCellClick(r, c) {
            if(winLine || isPassing || board[r][c].open) return;
            if(mode === 'online' && currentPlayer !== myId) return;

            if(!firstSelect) {
                firstSelect = {r, c};
            } else {
                // „ÄêÊ©üËÉΩ4Ôºö„Ç≠„É£„É≥„Çª„É´Ë™øÊï¥„ÄëÂêå„Åò„Éû„Çπ„ÇíÂè©„ÅÑ„Åü„ÇâËß£Èô§
                if(firstSelect.r === r && firstSelect.c === c) {
                    firstSelect = null;
                } else {
                    let dr = Math.abs(r - firstSelect.r), dc = Math.abs(c - firstSelect.c);
                    if(dr === 0 && dc === 0) commit([{r, c, open: true}]);
                    else if(dr + dc === 1) commit([{r: firstSelect.r, c: firstSelect.c, open: false}, {r, c, open: false}]);
                    else firstSelect = {r, c};
                }
            }
            updateUI();
        }

        function commit(moves) {
            moves.forEach(m => {
                let cell = board[m.r][m.c];
                if(cell.p !== 0 || m.open) cell.open = true;
                cell.p = currentPlayer;
                moveHistory.push({r: m.r, c: m.c, p: currentPlayer});
            });

            if(checkWin(currentPlayer)) {
                endGame(`PLAYER ${currentPlayer} WIN!`);
            } else {
                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                firstSelect = null;
                if(mode === 'offline') {
                    isPassing = true;
                    document.getElementById('pass-overlay').style.display = 'flex';
                    document.getElementById('pass-player-name').innerText = `PLAYER ${currentPlayer} TURN`;
                } else if(mode === 'ai' && currentPlayer === 2) {
                    setTimeout(executeAIMove, 600);
                } else if(mode === 'online') {
                    syncOnline();
                }
            }
            updateUI();
        }

        function executeAIMove() {
            // „ÄêÊ©üËÉΩ5ÔºöÂ≠¶ÁøíÂûãAI„ÄëÈÅéÂéª„Éá„Éº„Çø„Å´Âü∫„Å•„Åç„Çπ„Ç≥„Ç¢„É™„É≥„Ç∞
            let candidates = [];
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    if(!board[r][c].open) {
                        let weight = learnedData.filter(d => d.r === r && d.c === c).length;
                        candidates.push({r, c, w: weight + Math.random()});
                    }
                }
            }
            candidates.sort((a,b) => b.w - a.w);
            let m1 = candidates[0];
            let m2 = candidates.find(c => Math.abs(c.r-m1.r)+Math.abs(c.r-m1.c) === 1) || candidates[1];
            commit([{r: m1.r, c: m1.c, open:false}, {r: m2.r, c: m2.c, open:false}]);
        }

        function checkWin(p) {
            const dirs = [[1,0],[0,1],[1,1],[1,-1]];
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    if(board[r][c].p === p && board[r][c].open) {
                        for(let [dr,dc] of dirs) {
                            let line = [];
                            for(let i=0; i<5; i++) {
                                let nr=r+dr*i, nc=c+dc*i;
                                if(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&board[nr][nc].p===p&&board[nr][nc].open) line.push({r:nr,c:nc});
                                else break;
                            }
                            if(line.length === 5) { winLine = line; return true; }
                        }
                    }
                }
            }
            return false;
        }

        function updateUI() {
            const tokens = document.querySelectorAll('.token');
            const cells = document.querySelectorAll('.cell');
            board.flat().forEach((cell, i) => {
                let t = tokens[i];
                t.style.backgroundColor = cell.p === 1 ? 'var(--p1)' : 'var(--p2)';
                let isMe = (mode === 'offline' && !isPassing && cell.p === currentPlayer) || (mode === 'ai' && cell.p === 1) || (mode === 'online' && cell.p === myId);
                
                // „ÄêÊ©üËÉΩ3ÔºöÂÖ®ÂÖ¨Èñã„É™„Éó„É¨„Ç§„ÄëÂãùÂà©ÊôÇ„ÅØÂÖ®Èßí„Ç™„Éº„Éó„É≥
                if(cell.open || winLine) t.className = 'token show opened';
                else if(isMe && cell.p !== 0) t.className = 'token show stealth';
                else t.className = 'token';

                if(winLine && winLine.some(l => l.r === Math.floor(i/SIZE) && l.c === i%SIZE)) t.classList.add('win-token');
                
                let r = Math.floor(i/SIZE), c = i%SIZE;
                cells[i].style.background = (firstSelect && firstSelect.r===r && firstSelect.c===c) ? 'rgba(59, 130, 246, 0.2)' : 'var(--panel)';
            });
            document.getElementById('p1-ui').classList.toggle('active', currentPlayer===1);
            document.getElementById('p2-ui').classList.toggle('active', currentPlayer===2);
            document.getElementById('status-msg').innerText = winLine ? "GAME OVER" : `TURN: P${currentPlayer}`;
        }

        function startTimer() {
            timerId = setInterval(() => {
                if(winLine || isPassing) return;
                if(currentPlayer === 1) { if(p1Time > 0) p1Time--; else p1Byo--; if(p1Byo<0) endGame("P2 WIN (TIME)"); }
                else { if(p2Time > 0) p2Time--; else p2Byo--; if(p2Byo<0) endGame("P1 WIN (TIME)"); }
                const f = (t, b) => `${Math.floor(t/60)}:${(t%60).toString().padStart(2,'0')}${t<=0?` (${b})`:''}`;
                document.getElementById('p1-t').innerText = f(p1Time, p1Byo);
                document.getElementById('p2-t').innerText = f(p2Time, p2Byo);
            }, 1000);
        }

        function endGame(m) {
            clearInterval(timerId);
            updateUI();
            db.ref('game_logs').push({winner: currentPlayer, history: moveHistory, date: Date.now()});
            setTimeout(() => { alert(m); location.reload(); }, 1200);
        }

        // --- Utils ---
        function resumeFromPass() { isPassing = false; document.getElementById('pass-overlay').style.display = 'none'; updateUI(); }
        function openSettings() { document.getElementById('settings-overlay').style.display = 'flex'; }
        function applySettings() {
            configMin = parseInt(document.getElementById('cfg-min').value) || 10;
            configByo = parseInt(document.getElementById('cfg-byo').value) || 30;
            initBoard(); closeOverlays();
        }
        function showOnlineSetup() { document.getElementById('online-overlay').style.display = 'flex'; }
        function connectOnline() {
            const kw = document.getElementById('match-kw').value.trim();
            if(!kw) return;
            dbRef = db.ref('rooms/' + kw);
            dbRef.get().then(snap => {
                myId = snap.exists() ? 2 : 1;
                dbRef.on('value', s => {
                    const d = s.val(); if(!d) return;
                    board = d.board; currentPlayer = d.turn;
                    if(d.win) endGame(`PLAYER ${currentPlayer===1?2:1} WIN!`);
                    updateUI();
                });
                setupGame('online');
            });
        }
        function syncOnline() { if(dbRef) dbRef.set({ board, turn: currentPlayer, win: !!winLine }); }
        function closeOverlays() { document.querySelectorAll('.overlay').forEach(o => { if(o.id !== 'menu-overlay') o.style.display = 'none'; }); }
        function handleReset() { if(confirm("RESET GAME?")) location.reload(); }
        function showLogs() {
            db.ref('game_logs').limitToLast(5).once('value', s => {
                let str = "RECENT RESULTS:\n";
                s.forEach(i => { str += `> P${i.val().winner} WON (${new Date(i.val().date).toLocaleDateString()})\n`; });
                alert(str || "No data yet.");
            });
        }
    </script>
</body>
</html>
